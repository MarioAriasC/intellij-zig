{
  parserClass="org.ziglang.psi.parser.ZigLangParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Zig"
  psiImplClassSuffix="Impl"
  psiPackage="org.ziglang.psi"
  psiImplPackage="org.ziglang.psi.impl"

  elementTypeHolderClass="org.ziglang.psi.ZigLangTypes"
  elementTypeClass="org.ziglang.psi.ZigLangElementType"
  tokenTypeClass="org.ziglang.psi.ZigLangTokenType"
tokens = [

PUB='pub'
FN='fn'
CONST='const'
VAR='var'
EQUAL='='
LETTERC='c'
OR='or'
AND='and'
EXPORT='export'
EXTERN='extern'
INLINE='inline'
NOINLINE='noinline'
THREAD_LOCAL='threadlocal'
USING_NAME_SPACE='usingnamespace'
ALIGN='align'
LINKSECTION='linksection'
CALLCONV='callconv'
COMPTIME='comptime'
ANY_TYPE='anytype'
TEST='test'
NOSUSPEND='nosuspend'
SUSPEND='suspend'
DEFER='defer'
ERRDEFER='errdefer'
FOR='for'
WHILE='while'
SWITCH='switch'
BREAK='break'
CONTINUE='continue'
RESUME='resume'
ASM='asm'
VOLATILE='volatile'
ANYFRAME='anyframe'
ALLOWZERO='allowzero'
ASYNC='async'

EQUALEQUAL='=='
LARROW='<'
RARROW='>'
EXCLAMATIONMARK='!'
EXCLAMATIONMARKEQUAL='!='
LARROWEQUAL='<='
RARROWEQUAL='>='
AMPERSAND='&'
CARET='^'
PIPE='|'
ORELSE='orelse'
catch='catch'
LARROW2='<<'
RARROW2='>>'
PLUS='+'
MINUS='-'
PLUS2='++'
PLUSPERCENT='+%'
MINUSPERCENT='-%'
PIPE2='||'
ASTERISK='*'
SLASH='/'
PERCENT='%'
ASTERISK2='**'
ASTERISKPERCENT='*%'
IF='if'
RETURN='return'
ELSE='else'
LBRACE='{'
RBRACE='}'
ASTERISKEQUAL='*='
SLASHEQUAL='/='
PERCENTEQUAL='%='
PLUSEQUAL='+='
MINUSEQUAL='-='
LARROW2EQUAL='<<='
RARROW2EQUAL='>>='
AMPERSANDEQUAL='&='
CARETEQUAL='^='
EQUALRARROW='=>'
MINUSRARROW='->'
PIPEEQUAL='|='
ASTERISKPERCENTEQUAL='*%='
PLUSPERCENTEQUAL='+%='
MINUSPERCENTEQUAL='-%='
TILDE='~'
DOT='.'
DOT2='..'
DOT3='...'
TRY='try'
LBRACKET='['
RBRACKET=']'
DOTASTERISK='.*'
QUESTIONMARK='?'
DOTQUESTIONMARK='.?'
SEMICOLON=';'
LPAREN='('
RPAREN=')'
COMMA=','
COLON=':'
]
}


root ::= container_doc_comment? ContainerDeclarations?
private container_doc_comment ::= CONTAINER_DOC+
private ContainerMembers ::= ContainerDeclarations? (ContainerField COMMA)* (ContainerField | ContainerDeclarations?)
private ContainerDeclarations ::=
    TestDecl ContainerDeclarations?
    | TopLevelComptime ContainerDeclarations?
    | DocComment? PUB? TopLevelDecl ContainerDeclarations?

TopLevelComptime ::= DocComment? COMPTIME BlockExpr

TestDecl ::= DocComment? TEST STRINGLITERALSINGLE? Block

private DocComment ::= COMMENT+
private TopLevelDecl ::=
    (EXPORT | EXTERN STRINGLITERALSINGLE? | (INLINE | NOINLINE))?  FnProto (SEMICOLON | Block)
    |(EXPORT | EXTERN STRINGLITERALSINGLE?)? THREAD_LOCAL? VarDecl
    | USING_NAME_SPACE Expr SEMICOLON

private FnProto ::= FN ID? LPAREN ParamDeclList RPAREN ByteAlign? LinkSection? CallConv? EXCLAMATIONMARK?  TypeExpr
ByteAlign ::= ALIGN LPAREN Expr RPAREN
LinkSection ::= LINKSECTION LPAREN Expr RPAREN
CallConv ::= CALLCONV LPAREN Expr RPAREN

ParamDeclList ::= (ParamDecl COMMA)* ParamDecl?
ParamDecl ::= (ID COLON)? ParamType
ParamType ::= TypeExpr
TypeExpr ::= PrefixTypeOp* ErrorUnionExpr
PrefixTypeOp ::=
    QUESTIONMARK
    | ANYFRAME MINUSRARROW
    | SliceTypeStart (ByteAlign | CONST | VOLATILE | ALLOWZERO)*
    | PtrTypeStart (ALIGN LPAREN Expr (COLON INTEGER COLON INTEGER)? RPAREN | CONST | VOLATILE| ALLOWZERO)*
    | ArrayTypeStart

SliceTypeStart ::= LBRACKET (COLON Expr)? RBRACKET
PtrTypeStart ::=
    ASTERISK
    | ASTERISK2
    | LBRACKET ASTERISK (LETTERC | COLON Expr)? RBRACKET

ArrayTypeStart ::= LBRACKET Expr (COLON Expr)? RBRACKET

ErrorUnionExpr ::= SuffixExpr | (EXCLAMATIONMARK TypeExpr)?
SuffixExpr ::=
    ASYNC PrimaryTypeExpr SuffixOp* FnCallArguments
    | PrimaryTypeExpr (SuffixOp | FnCallArguments)*
SuffixOp ::= LBRACKET Expr (DOT2 (Expr? (COLON Expr)?)?)? RBRACKET
                  | DOT ID
                  | DOTASTERISK
                  | DOTQUESTIONMARK
PrimaryTypeExpr ::=
    BUILTINIDENTIFIER FnCallArguments
    | CHAR_LITERAL
    | ContainerDecl
    | DOT ID
    | DOT InitList
    | ErrorSetDecl
    | FLOAT
    | FnProto
    | GroupedExpr
    | LabeledTypeExpr
    | ID
    | INTEGER
    | STRINGLITERAL

ContainerDecl ::= (EXTERN | PACKED)? ContainerDeclAuto
ContainerDeclAuto ::= ContainerDeclType LBRACE container_doc_comment? ContainerMembers RBRACE
ContainerDeclType ::=
    STRUCT
    | OPAQUE
    | ENUM (LPAREN Expr RPAREN)?
    | UNION (LPAREN (ENUM (LPAREN Expr RPAREN)? | Expr) RPAREN)?

ErrorSetDecl ::= ERROR LBRACE IdentifierList RBRACE

GroupedExpr ::= LPAREN Expr RPAREN

LabeledTypeExpr ::= BlockLabel Block | BlockLabel? LoopTypeExpr

LoopTypeExpr ::= INLINE? (ForTypeExpr | WhileTypeExpr)

ForTypeExpr ::= ForPrefix TypeExpr (ELSE TypeExpr)?
WhileTypeExpr ::= WhilePrefix TypeExpr (ELSE Payload? TypeExpr)?

IdentifierList ::= (DocComment? ID COMMA)* (DocComment? ID)?
STRINGLITERAL ::= STRINGLITERALSINGLE
BUILTINIDENTIFIER ::='@' ID
FnCallArguments ::= LPAREN ExprList RPAREN
ExprList ::= (Expr COMMA)* Expr?

VarDecl ::= (CONST |VAR) ID (COLON TypeExpr)? ByteAlign? LinkSection? (EQUAL Expr)? SEMICOLON

ContainerField ::= DocComment? COMPTIME? ID (COLON (ANY_TYPE|TypeExpr) ByteAlign?)? (EQUAL Expr)?

Expr ::= BoolOrExpr
BoolOrExpr ::= BoolAndExpr (OR BoolAndExpr)*
BoolAndExpr ::= CompareExpr (AND CompareExpr)*
CompareExpr ::= BitwiseExpr (CompareOp BitwiseExpr)?
CompareOp ::= EQUALEQUAL | EXCLAMATIONMARKEQUAL |LARROW |RARROW|LARROWEQUAL|RARROWEQUAL
BitwiseExpr ::= BitShiftExpr (BitwiseOp BitShiftExpr)*

BitwiseOp ::= AMPERSAND | CARET | PIPE | orelse | catch Payload?
Payload ::= PIPE ID PIPE

BitShiftExpr ::= AdditionExpr (BitShiftOp AdditionExpr)*
BitShiftOp ::=  LARROW2 | RARROW2
AdditionExpr ::= MultiplyExpr (AdditionOp MultiplyExpr)*
AdditionOp ::= PLUS | MINUS | PLUS2 | PLUSPERCENT | MINUSPERCENT
MultiplyExpr ::= PrefixExpr (MultiplyOp PrefixExpr)*
MultiplyOp ::= PIPE2 | ASTERISK | SLASH | PERCENT | ASTERISK2 | ASTERISKPERCENT
PrefixExpr ::= PrefixOp* PrimaryExpr
PrimaryExpr::=
    AsmExpr
    | IfExpr
    | BREAK BreakLabel? Expr?
    | COMPTIME Expr
    | NOSUSPEND Expr
    | CONTINUE BreakLabel?
    | RESUME Expr
    | RETURN Expr?
    | BlockLabel? LoopExpr
    | Block
    | CurlySuffixExpr

AsmExpr ::= ASM VOLATILE? LPAREN Expr AsmOutput? RPAREN
AsmOutput ::= COLON AsmOutputList AsmInput?

AsmOutputList ::= (AsmOutputItem COMMA)* AsmOutputItem?
AsmOutputItem ::= LBRACKET ID RBRACKET STRINGLITERAL LPAREN (MINUSRARROW TypeExpr | ID) RPAREN
AsmInput ::= COLON AsmInputList AsmClobbers?
AsmInputList ::= (AsmInputItem COMMA)* AsmInputItem
AsmInputItem ::= LBRACKET ID RBRACKET STRINGLITERAL LPAREN Expr RPAREN
AsmClobbers ::= COLON StringList
StringList ::= (STRINGLITERAL COMMA)* STRINGLITERAL?

BreakLabel ::= COLON ID

LoopExpr ::= INLINE? (ForExpr | WhileExpr)
ForExpr ::= ForPrefix Expr (ELSE Expr)?
WhileExpr ::= WhilePrefix Expr (ELSE Payload? Expr)?

CurlySuffixExpr ::= TypeExpr InitList?
InitList ::=
    LBRACE FieldInit (COMMA FieldInit)* COMMA? RBRACE
    | LBRACE Expr (COMMA Expr)* COMMA? RBRACE
    | LBRACE RBRACE

FieldInit ::= DOT ID EQUAL Expr

IfExpr ::= IfPrefix Expr (ELSE Payload? Expr)?
IfPrefix ::= IF LPAREN Expr RPAREN PtrPayload?
PtrPayload ::= PIPE ASTERISK? ID PIPE
Block ::= LBRACE Statement* RBRACE

BlockExpr ::= BlockLabel? Block
BlockLabel ::= ID COLON
Statement ::=
    VarDecl
    | COMPTIME BlockExprStatement
    | NOSUSPEND BlockExprStatement
    | SUSPEND BlockExprStatement
    | DEFER BlockExprStatement
    | ERRDEFER Payload? BlockExprStatement
    | IfStatement
    | LabeledStatement
    | SwitchExpr
    | AssignExpr SEMICOLON

IfStatement ::=
    IfPrefix BlockExpr (ELSE Payload? Statement)?
    | IfPrefix AssignExpr (SEMICOLON | ELSE Payload? Statement)

LabeledStatement ::= BlockLabel? (Block | LoopStatement)

LoopStatement ::= INLINE? (ForStatement | WhileStatement)

ForStatement ::=
    ForPrefix BlockExpr (ELSE Statement)?
    | ForPrefix AssignExpr (SEMICOLON | ELSE Statement)

WhileStatement ::=
    WhilePrefix BlockExpr (ELSE Payload? Statement)?
    | WhilePrefix AssignExpr (SEMICOLON | ELSE Payload? Statement)

SwitchExpr ::= SWITCH LPAREN Expr RPAREN LBRACE SwitchProngList RBRACE
SwitchProngList ::= (SwitchProng COMMA)* SwitchProng
SwitchProng ::= SwitchCase EQUALRARROW PtrPayload? AssignExpr
SwitchCase ::= SwitchItem (COMMA SwitchItem)* COMMA? | ELSE
SwitchItem ::= Expr (DOT3 Expr)?
ForPrefix ::= FOR LPAREN Expr RPAREN PtrIndexPayload
WhilePrefix ::= WHILE LPAREN Expr RPAREN PtrPayload? WhileContinueExpr?
WhileContinueExpr ::= COLON LPAREN AssignExpr RPAREN

PtrIndexPayload ::= PIPE ASTERISK? ID (COMMA ID)? PIPE

BlockExprStatement ::= BlockExpr | AssignExpr SEMICOLON
AssignExpr ::= Expr (AssignOp Expr)?
AssignOp
    ::= ASTERISKEQUAL
     | SLASHEQUAL
     | PERCENTEQUAL
     | PLUSEQUAL
     | MINUSEQUAL
     | LARROW2EQUAL
     | RARROW2EQUAL
     | AMPERSANDEQUAL
     | CARETEQUAL
     | PIPEEQUAL
     | ASTERISKPERCENTEQUAL
     | PLUSPERCENTEQUAL
     | MINUSPERCENTEQUAL
     | EQUAL

PrefixOp
    ::= EXCLAMATIONMARK
     | MINUS
     | TILDE
     | MINUSPERCENT
     | AMPERSAND
     | TRY
     | AWAIT